\hypertarget{heap_8c}{}\doxysection{src/heap.c File Reference}
\label{heap_8c}\index{src/heap.c@{src/heap.c}}


functions for heap  


{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$stdbool.\+h$>$}\newline
{\ttfamily \#include \char`\"{}../include/heap.\+h\char`\"{}}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{heap_8c_ab43d0eafaa5ff8ac2dba0657750fdf4c}{init\+\_\+heap}} (\mbox{\hyperlink{structHeap}{Heap}} $\ast$h)
\begin{DoxyCompactList}\small\item\em initialize a new heap \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{heap_8c_a85f425d55995d4bfe7d42a8317fcbedc}{is\+\_\+heap\+\_\+empty}} (\mbox{\hyperlink{structHeap}{Heap}} $\ast$h)
\begin{DoxyCompactList}\small\item\em test if heap is empty or not \end{DoxyCompactList}\item 
int \mbox{\hyperlink{heap_8c_ab2fb784df206f93de31980e0857238eb}{get\+Parent\+Index}} (int child\+Index)
\begin{DoxyCompactList}\small\item\em Get the Parent Index. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{heap_8c_a080429fc08f3f8c164dabed49602fc59}{get\+Left\+Child\+Index}} (int parent\+Index)
\begin{DoxyCompactList}\small\item\em Get the Left Child Index. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{heap_8c_a211e1f0d0e3ad61c03562126c240b732}{get\+Right\+Child\+Index}} (int parent\+Index)
\begin{DoxyCompactList}\small\item\em Get the Right Child Index. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{heap_8c_a3a09ca62cfc0c356b79372ca3aa23e7d}{swap\+\_\+heap}} (\mbox{\hyperlink{structHeap}{Heap}} $\ast$h, int index1, int index2)
\begin{DoxyCompactList}\small\item\em Swap two values ​​in the heap. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{heap_8c_aad6a0cf72f70bfa1b346c26b29f4fab0}{heapify\+Up}} (\mbox{\hyperlink{structHeap}{Heap}} $\ast$h)
\begin{DoxyCompactList}\small\item\em Rearrange starting from the end. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{heap_8c_a66d9cc261e16d5e73ff78618023b5b54}{heapify\+Down}} (\mbox{\hyperlink{structHeap}{Heap}} $\ast$h)
\begin{DoxyCompactList}\small\item\em Reorganized from the beginning. \end{DoxyCompactList}\item 
float \mbox{\hyperlink{heap_8c_a9522d3476ad97c341585c4dd3fd9eb01}{pop\+\_\+heap}} (\mbox{\hyperlink{structHeap}{Heap}} $\ast$h)
\begin{DoxyCompactList}\small\item\em remove the first element \end{DoxyCompactList}\item 
void \mbox{\hyperlink{heap_8c_af9b4814c7eb4fd7f934e9836e1016d95}{push\+\_\+heap}} (\mbox{\hyperlink{structHeap}{Heap}} $\ast$h, float value)
\begin{DoxyCompactList}\small\item\em add value \end{DoxyCompactList}\item 
float \mbox{\hyperlink{heap_8c_a54c0ba5c00a105a220a161ec717208a7}{replace}} (\mbox{\hyperlink{structHeap}{Heap}} $\ast$h, float value)
\begin{DoxyCompactList}\small\item\em return the first value of a heap and replace it by a new value \end{DoxyCompactList}\item 
float \mbox{\hyperlink{heap_8c_a6dd0912685947a8f652bc357f4e22fe8}{peek\+\_\+heap}} (\mbox{\hyperlink{structHeap}{Heap}} $\ast$h)
\begin{DoxyCompactList}\small\item\em return the first value of heap \end{DoxyCompactList}\item 
void \mbox{\hyperlink{heap_8c_a9472d07b0851b72596206637116d513d}{clear\+\_\+heap}} (\mbox{\hyperlink{structHeap}{Heap}} $\ast$h)
\begin{DoxyCompactList}\small\item\em clear heap \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
functions for heap 

\begin{DoxyAuthor}{Author}
Kubilay KAPLAN \& Emile METRAL 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
0.\+1 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
2021-\/10-\/15
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
Copyright (c) 2021 
\end{DoxyCopyright}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{heap_8c_a9472d07b0851b72596206637116d513d}\label{heap_8c_a9472d07b0851b72596206637116d513d}} 
\index{heap.c@{heap.c}!clear\_heap@{clear\_heap}}
\index{clear\_heap@{clear\_heap}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{clear\_heap()}{clear\_heap()}}
{\footnotesize\ttfamily void clear\+\_\+heap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap}{Heap}} $\ast$}]{h }\end{DoxyParamCaption})}



clear heap 


\begin{DoxyParams}{Parameters}
{\em h} & \mbox{\hyperlink{structHeap}{Heap}} adress to be treated \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{heap_8c_a080429fc08f3f8c164dabed49602fc59}\label{heap_8c_a080429fc08f3f8c164dabed49602fc59}} 
\index{heap.c@{heap.c}!getLeftChildIndex@{getLeftChildIndex}}
\index{getLeftChildIndex@{getLeftChildIndex}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{getLeftChildIndex()}{getLeftChildIndex()}}
{\footnotesize\ttfamily int get\+Left\+Child\+Index (\begin{DoxyParamCaption}\item[{int}]{parent\+Index }\end{DoxyParamCaption})}



Get the Left Child Index. 


\begin{DoxyParams}{Parameters}
{\em parent\+Index} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\Hypertarget{heap_8c_ab2fb784df206f93de31980e0857238eb}\label{heap_8c_ab2fb784df206f93de31980e0857238eb}} 
\index{heap.c@{heap.c}!getParentIndex@{getParentIndex}}
\index{getParentIndex@{getParentIndex}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{getParentIndex()}{getParentIndex()}}
{\footnotesize\ttfamily int get\+Parent\+Index (\begin{DoxyParamCaption}\item[{int}]{child\+Index }\end{DoxyParamCaption})}



Get the Parent Index. 


\begin{DoxyParams}{Parameters}
{\em child\+Index} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\Hypertarget{heap_8c_a211e1f0d0e3ad61c03562126c240b732}\label{heap_8c_a211e1f0d0e3ad61c03562126c240b732}} 
\index{heap.c@{heap.c}!getRightChildIndex@{getRightChildIndex}}
\index{getRightChildIndex@{getRightChildIndex}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{getRightChildIndex()}{getRightChildIndex()}}
{\footnotesize\ttfamily int get\+Right\+Child\+Index (\begin{DoxyParamCaption}\item[{int}]{parent\+Index }\end{DoxyParamCaption})}



Get the Right Child Index. 


\begin{DoxyParams}{Parameters}
{\em parent\+Index} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\Hypertarget{heap_8c_a66d9cc261e16d5e73ff78618023b5b54}\label{heap_8c_a66d9cc261e16d5e73ff78618023b5b54}} 
\index{heap.c@{heap.c}!heapifyDown@{heapifyDown}}
\index{heapifyDown@{heapifyDown}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{heapifyDown()}{heapifyDown()}}
{\footnotesize\ttfamily void heapify\+Down (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap}{Heap}} $\ast$}]{h }\end{DoxyParamCaption})}



Reorganized from the beginning. 


\begin{DoxyParams}{Parameters}
{\em h} & \mbox{\hyperlink{structHeap}{Heap}} adress to be treated \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{heap_8c_aad6a0cf72f70bfa1b346c26b29f4fab0}\label{heap_8c_aad6a0cf72f70bfa1b346c26b29f4fab0}} 
\index{heap.c@{heap.c}!heapifyUp@{heapifyUp}}
\index{heapifyUp@{heapifyUp}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{heapifyUp()}{heapifyUp()}}
{\footnotesize\ttfamily void heapify\+Up (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap}{Heap}} $\ast$}]{h }\end{DoxyParamCaption})}



Rearrange starting from the end. 


\begin{DoxyParams}{Parameters}
{\em h} & \mbox{\hyperlink{structHeap}{Heap}} adressto be treated \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{heap_8c_ab43d0eafaa5ff8ac2dba0657750fdf4c}\label{heap_8c_ab43d0eafaa5ff8ac2dba0657750fdf4c}} 
\index{heap.c@{heap.c}!init\_heap@{init\_heap}}
\index{init\_heap@{init\_heap}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{init\_heap()}{init\_heap()}}
{\footnotesize\ttfamily void init\+\_\+heap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap}{Heap}} $\ast$}]{h }\end{DoxyParamCaption})}



initialize a new heap 


\begin{DoxyParams}{Parameters}
{\em h} & \mbox{\hyperlink{structHeap}{Heap}} address to initialized \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{heap_8c_a85f425d55995d4bfe7d42a8317fcbedc}\label{heap_8c_a85f425d55995d4bfe7d42a8317fcbedc}} 
\index{heap.c@{heap.c}!is\_heap\_empty@{is\_heap\_empty}}
\index{is\_heap\_empty@{is\_heap\_empty}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{is\_heap\_empty()}{is\_heap\_empty()}}
{\footnotesize\ttfamily bool is\+\_\+heap\+\_\+empty (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap}{Heap}} $\ast$}]{h }\end{DoxyParamCaption})}



test if heap is empty or not 


\begin{DoxyParams}{Parameters}
{\em h} & \mbox{\hyperlink{structHeap}{Heap}} address to be treated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
heap is empty 

heap is not empty 
\end{DoxyReturn}
\mbox{\Hypertarget{heap_8c_a6dd0912685947a8f652bc357f4e22fe8}\label{heap_8c_a6dd0912685947a8f652bc357f4e22fe8}} 
\index{heap.c@{heap.c}!peek\_heap@{peek\_heap}}
\index{peek\_heap@{peek\_heap}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{peek\_heap()}{peek\_heap()}}
{\footnotesize\ttfamily float peek\+\_\+heap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap}{Heap}} $\ast$}]{h }\end{DoxyParamCaption})}



return the first value of heap 


\begin{DoxyParams}{Parameters}
{\em h} & \mbox{\hyperlink{structHeap}{Heap}} adress to be treated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
float 
\end{DoxyReturn}
\mbox{\Hypertarget{heap_8c_a9522d3476ad97c341585c4dd3fd9eb01}\label{heap_8c_a9522d3476ad97c341585c4dd3fd9eb01}} 
\index{heap.c@{heap.c}!pop\_heap@{pop\_heap}}
\index{pop\_heap@{pop\_heap}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{pop\_heap()}{pop\_heap()}}
{\footnotesize\ttfamily float pop\+\_\+heap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap}{Heap}} $\ast$}]{h }\end{DoxyParamCaption})}



remove the first element 


\begin{DoxyParams}{Parameters}
{\em h} & \mbox{\hyperlink{structHeap}{Heap}} adress to be treated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
float \+: element deleted 
\end{DoxyReturn}
\mbox{\Hypertarget{heap_8c_af9b4814c7eb4fd7f934e9836e1016d95}\label{heap_8c_af9b4814c7eb4fd7f934e9836e1016d95}} 
\index{heap.c@{heap.c}!push\_heap@{push\_heap}}
\index{push\_heap@{push\_heap}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{push\_heap()}{push\_heap()}}
{\footnotesize\ttfamily void push\+\_\+heap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap}{Heap}} $\ast$}]{h,  }\item[{float}]{value }\end{DoxyParamCaption})}



add value 


\begin{DoxyParams}{Parameters}
{\em h} & \mbox{\hyperlink{structHeap}{Heap}} adress to be treated \\
\hline
{\em value} & value to be added to the heap \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{heap_8c_a54c0ba5c00a105a220a161ec717208a7}\label{heap_8c_a54c0ba5c00a105a220a161ec717208a7}} 
\index{heap.c@{heap.c}!replace@{replace}}
\index{replace@{replace}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{replace()}{replace()}}
{\footnotesize\ttfamily float replace (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap}{Heap}} $\ast$}]{h,  }\item[{float}]{value }\end{DoxyParamCaption})}



return the first value of a heap and replace it by a new value 


\begin{DoxyParams}{Parameters}
{\em h} & \mbox{\hyperlink{structHeap}{Heap}} adress to be treated \\
\hline
{\em value} & replaced value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
float 
\end{DoxyReturn}
\mbox{\Hypertarget{heap_8c_a3a09ca62cfc0c356b79372ca3aa23e7d}\label{heap_8c_a3a09ca62cfc0c356b79372ca3aa23e7d}} 
\index{heap.c@{heap.c}!swap\_heap@{swap\_heap}}
\index{swap\_heap@{swap\_heap}!heap.c@{heap.c}}
\doxysubsubsection{\texorpdfstring{swap\_heap()}{swap\_heap()}}
{\footnotesize\ttfamily void swap\+\_\+heap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structHeap}{Heap}} $\ast$}]{h,  }\item[{int}]{index1,  }\item[{int}]{index2 }\end{DoxyParamCaption})}



Swap two values ​​in the heap. 


\begin{DoxyParams}{Parameters}
{\em h} & Table \\
\hline
{\em index1} & Value to be exchanged \\
\hline
{\em index2} & Value to be exchanged \\
\hline
\end{DoxyParams}
